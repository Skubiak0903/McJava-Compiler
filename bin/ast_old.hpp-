// ast.hpp
#pragma once

#include <variant>
#include <vector>
#include <string>
#include <memory>
#include "tokenization.hpp"

// ----------------------------------------------------
// NODE TYPES USING VARIANT + TEMPLATES
// ----------------------------------------------------

// 1. Forward declarations wszystkich struktur
struct CommandData;
struct VarDeclData;
struct ExprData;
struct BinaryOpData;
struct IfStmtData;
struct WhileLoopData;
struct ScopeData;

// 2. Twój NodeVariant (musi być pod forward deklaracjami)
template<typename... Ts>
struct NodeVariant : std::variant<Ts...> {
    using std::variant<Ts...>::variant;
    
    template<typename Visitor>
    auto visit(Visitor&& vis) const { // Dodaj const dla bezpieczeństwa
        return std::visit(std::forward<Visitor>(vis), *this);
    }
};

enum class DataType {
    INTEGER, FLOAT, BOOL, STRING
};

// MAIN NODE TYPE - DODAJESZ TYLKO TU NOWE TYPY!
using ASTNode = NodeVariant<
    CommandData,
    VarDeclData,
    ExprData,
    BinaryOpData,
    IfStmtData,
    WhileLoopData,
    ScopeData
    // DODAJ TU NOWE TYPY! np.:
    // FunctionCallData
>;

// Concrete node types (now can use ASTNode)
struct CommandData {
    Token cmd;
    std::vector<ASTNode> args;
};

struct VarDeclData {
    Token name;
    std::unique_ptr<ASTNode> value;
    //DataType type;
};

struct ExprData {
    Token token;
    //DataType type;
};


struct BinaryOpData {
    Token op;
    std::unique_ptr<ASTNode> left;
    std::unique_ptr<ASTNode> right;
    //DataType type;
};

struct IfStmtData {
    std::unique_ptr<ASTNode> condition;
    std::unique_ptr<ASTNode> thenBranch;  // zawsze musi być
    std::unique_ptr<ASTNode> elseBranch;  // może być nullptr
};

struct WhileLoopData {
    std::unique_ptr<ASTNode> condition;
    std::unique_ptr<ASTNode> body;
};

struct ScopeData {
    std::vector<ASTNode> statements;
};


// ----------------------------------------------------
// EASY NODE CREATION
// ----------------------------------------------------

inline ASTNode make_command(Token cmd, std::vector<ASTNode> args = {}) {
    return CommandData{cmd, std::move(args)};
}

inline ASTNode make_vardecl(Token name, ASTNode value) {
    return VarDeclData{name, std::make_unique<ASTNode>(std::move(value))};
}

inline ASTNode make_expr(Token token) {
    return ExprData{token};
}

inline ASTNode make_binary_op(Token op, ASTNode left, ASTNode right) {
    return BinaryOpData{op, 
                        std::make_unique<ASTNode>(std::move(left)), 
                        std::make_unique<ASTNode>(std::move(right))};
}

inline ASTNode make_block(std::vector<ASTNode> statements) {
    return ScopeData{std::move(statements)};
}

inline ASTNode make_if(ASTNode condition, ASTNode thenBranch, ASTNode elseBranch = {}) {
    return IfStmtData{
        std::make_unique<ASTNode>(std::move(condition)),
        std::make_unique<ASTNode>(std::move(thenBranch)),
        std::make_unique<ASTNode>(std::move(elseBranch))
    };
}

inline ASTNode make_while(ASTNode condition, ASTNode body) {
    return WhileLoopData{
        std::make_unique<ASTNode>(std::move(condition)),
        std::make_unique<ASTNode>(std::move(body))
    };
}


// ----------------------------------------------------
// VISITOR TEMPLATE FOR GENERATION
// ----------------------------------------------------

class ASTVisitor {
public:
    virtual void visit_command(const CommandData& cmd) = 0;
    virtual void visit_vardecl(const VarDeclData& decl) = 0;
    virtual void visit_expr(const ExprData& expr) = 0;
    virtual void visit_binary_op(const BinaryOpData& op) = 0;
    virtual void visit_if_stmt(const IfStmtData& op) = 0;
    virtual void visit_while_loop(const WhileLoopData& op) = 0;
    virtual void visit_scope(const ScopeData& op) = 0;
};

// Helper to apply visitor to node
inline void apply_visitor(const ASTNode& node, ASTVisitor& visitor) {
    std::visit([&](auto&& arg) {
        using T = std::decay_t<decltype(arg)>;
        
        if constexpr (std::is_same_v<T, CommandData>) {
            visitor.visit_command(arg);
        } else if constexpr (std::is_same_v<T, VarDeclData>) {
            visitor.visit_vardecl(arg);
        } else if constexpr (std::is_same_v<T, ExprData>) {
            visitor.visit_expr(arg);
        } else if constexpr (std::is_same_v<T, BinaryOpData>) {
            visitor.visit_binary_op(arg);
        } else if constexpr (std::is_same_v<T, IfStmtData>) {
            visitor.visit_if_stmt(arg);
        } else if constexpr (std::is_same_v<T, WhileLoopData>) {
            visitor.visit_while_loop(arg);
        } else if constexpr (std::is_same_v<T, ScopeData>) {
            visitor.visit_scope(arg);
        }

        // DODAJESZ TYLKO JEDEN IF_CONSTEXPR DLA NOWEGO TYPU!
    }, node);
}


// DUMP AST FOR DEBUGGING
inline void dump_ast(const ASTNode& node, std::ostream& out, int indent = 0) {
    auto indent_str = [&]() {
        for (int i = 0; i < indent; ++i) out << "  ";
    };
    
    std::visit([&](auto&& arg) {
        using T = std::decay_t<decltype(arg)>;
        
        if constexpr (std::is_same_v<T, CommandData>) {
            indent_str();
            out << "Command: " << arg.cmd.value.value_or("[no cmd]") << "\n";
            for (const auto& arg_node : arg.args) {
                dump_ast(arg_node, out, indent + 1);
            }
        }
        else if constexpr (std::is_same_v<T, VarDeclData>) {
            indent_str();
            out << "VarDecl: " << arg.name.value.value_or("[no name]") << "\n";
            dump_ast(*arg.value, out, indent + 1);
        }
        else if constexpr (std::is_same_v<T, ExprData>) {
            indent_str();
            out << "Expr: " << arg.token.value.value_or("[no value]") 
                << " [" << tokenTypeToString(arg.token.type) << "]\n";
        }
        else if constexpr (std::is_same_v<T, BinaryOpData>) {
            indent_str();
            out << "BinaryOp: " << arg.op.value.value_or("[no op]") 
                << " [" << tokenTypeToString(arg.op.type) << "]\n";
            dump_ast(*arg.left, out, indent + 1);
            dump_ast(*arg.right, out, indent + 1);
        }
        else if constexpr (std::is_same_v<T, IfStmtData>) {
            indent_str();
            out << "IfStmt\n";
            dump_ast(*arg.condition, out, indent + 1);
            dump_ast(*arg.thenBranch, out, indent + 1);
            if (arg.elseBranch) {
                indent_str();
                out << "else:\n";
                dump_ast(*arg.elseBranch, out, indent + 1);
            }
        }
        else if constexpr (std::is_same_v<T, WhileLoopData>) {
            indent_str();
            out << "WhileLoop\n";
            dump_ast(*arg.condition, out, indent + 1);
            dump_ast(*arg.body, out, indent + 1);
        }
        else if constexpr (std::is_same_v<T, ScopeData>) {
            indent_str();
            out << "Scope {\n";
            for (const auto& stmt : arg.statements) {
                dump_ast(stmt, out, indent + 1);
            }
            indent_str();
            out << "}\n";
        }
    }, node);
}